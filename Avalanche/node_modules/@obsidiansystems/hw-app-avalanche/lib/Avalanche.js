"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bip32Path = require("bip32-path");

var _bip32Path2 = _interopRequireDefault(_bip32Path);

var _createHash = require("create-hash");

var _createHash2 = _interopRequireDefault(_createHash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/**
 * Avalanche API
 *
 * @example
 * import Avalanche from "@obsidiansystems/hw-app-avalanche";
 * const avalanche = new Avalanche(transport);
 */
class Avalanche {

  constructor(transport, scrambleKey = "Avalanche", logger = console.error) {
    this.CLA = 0x80;
    this.MAX_APDU_SIZE = 230;
    this.MAX_HRP_LENGTH = 24;
    this.INS_VERSION = 0x00;
    this.INS_GET_WALLET_ID = 0x01;
    this.INS_PROMPT_PUBLIC_KEY = 0x02;
    this.INS_PROMPT_EXT_PUBLIC_KEY = 0x03;
    this.INS_SIGN_HASH = 0x04;
    this.INS_SIGN_TRANSACTION = 0x05;

    this.transport = transport;
    this.logger = logger;
    if (scrambleKey) {
      transport.decorateAppAPIMethods(this, ["getAppConfiguration", "getWalletAddress", "getWalletExtendedPublicKey", "getWalletId", "signHash", "signTransaction"], scrambleKey);
    }
  }

  /**
   * get Avalanche address for a given BIP-32 path.
   *
   * @param derivation_path a path in BIP 32 format
   * @return a buffer with a public key, and TODO: should be address, not public key
   * @example
   * await avalanche.getWalletPublicKey("44'/9000'/0'/0/0");
   */
  getWalletAddress(derivation_path, hrp = "") {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (hrp.length > _this.MAX_HRP_LENGTH) {
        throw "Maximum Bech32 'human readable part' length exceeded";
      }

      const cla = _this.CLA;
      const ins = _this.INS_PROMPT_PUBLIC_KEY;
      const p1 = hrp.length;
      const p2 = 0x00;
      const data = Buffer.concat([Buffer.from(hrp, "latin1"), _this.encodeBip32Path(_bip32Path2.default.fromString(derivation_path))]);

      const response = yield _this.transport.send(cla, ins, p1, p2, data);
      return response.slice(0, -2);
    })();
  }

  /**
   * get extended public key for a given BIP-32 path.
   *
   * @param derivation_path a path in BIP-32 format
   * @return an object with a buffer for the public key data and a buffer for the chain code
   * @example
   * await avalanche.getWalletExtendedPublicKey("44'/9000'/0'/0/0");
   */
  getWalletExtendedPublicKey(derivation_path) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const cla = _this2.CLA;
      const ins = _this2.INS_PROMPT_EXT_PUBLIC_KEY;
      const p1 = 0x00;
      const p2 = 0x00;
      const data = _this2.encodeBip32Path(_bip32Path2.default.fromString(derivation_path));

      const response = yield _this2.transport.send(cla, ins, p1, p2, data);
      const publicKeyLength = response[0];
      const chainCodeOffset = 2 + publicKeyLength;
      const chainCodeLength = response[1 + publicKeyLength];
      return {
        public_key: response.slice(1, 1 + publicKeyLength),
        chain_code: response.slice(chainCodeOffset, chainCodeOffset + chainCodeLength)
      };
    })();
  }

  /**
   * Sign a hash with a given set of BIP-32 paths.
   *
   * @param derivationPathPrefix a BIP-32 path that will act as the prefix to all other signing paths.
   * @param derivationPathSuffixes an array of BIP-32 path suffixes that will be
   *                               appended to the prefix to form the final path for signing.
   * @param hash 32-byte buffer containing the hash to sign
   * @return a map of path suffixes (as strings) to signature buffers
   * @example
   * const signatures = await avalanche.signHash(
   *   BIPPath.fromString("44'/9000'/0'"),
   *   [BIPPath.fromString("0/0")],
   *   Buffer.from("0000000000000000000000000000000000000000000000000000000000000000", "hex"));
   */
  signHash(derivationPathPrefix, derivationPathSuffixes, hash) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      if (hash.length != 32) {
        throw "Hash buffer must be 32 bytes";
      }

      const firstMessage = Buffer.concat([_this3.uInt8Buffer(derivationPathSuffixes.length), hash, _this3.encodeBip32Path(derivationPathPrefix)]);
      const responseHash = yield _this3.transport.send(_this3.CLA, _this3.INS_SIGN_HASH, 0x00, 0x00, firstMessage);
      if (!responseHash.slice(0, 32).equals(hash)) {
        throw "Ledger reported a hash that does not match the input hash!";
      }

      return _this3._collectSignaturesFromSuffixes(derivationPathSuffixes, _this3.INS_SIGN_HASH, 0x01, 0x81);
    })();
  }

  /**
   * Sign a transaction with a given set of BIP-32 paths.
   *
   * @param derivationPathPrefix a BIP-32 path that will act as the prefix to all other signing paths.
   * @param derivationPathSuffixes an array of BIP-32 path suffixes that will be
   *                               appended to the prefix to form the final path for signing.
   * @param txn binary of the transaction
   * @return an object with a hash of the transaction and a map of path suffixes (as strings) to signature buffers
   * @example
   * const signatures = await avalanche.signTransaction(
   *   BIPPath.fromString("44'/9000'/0'"),
   *   [BIPPath.fromString("0/0")],
   *   Buffer.from("...", "hex"),
   *   BIPPath.fromString("44'/9000'/0'/0'/0'"));
   * );
   */
  signTransaction(derivationPathPrefix, derivationPathSuffixes, txn, changePath) {
    var _this4 = this;

    return _asyncToGenerator(function* () {

      const SIGN_TRANSACTION_SECTION_PREAMBLE = 0x00;
      const SIGN_TRANSACTION_SECTION_PAYLOAD_CHUNK = 0x01;
      const SIGN_TRANSACTION_SECTION_PAYLOAD_CHUNK_LAST = 0x81;
      const SIGN_TRANSACTION_SECTION_SIGN_WITH_PATH = 0x02;
      const SIGN_TRANSACTION_SECTION_SIGN_WITH_PATH_LAST = 0x82;

      const preamble = Buffer.concat([_this4.uInt8Buffer(derivationPathSuffixes.length), _this4.encodeBip32Path(derivationPathPrefix)]);
      if (changePath != null) {
        const preamble_ = Buffer.concat([preamble, _this4.encodeBip32Path(changePath)]);
        yield _this4.transport.send(_this4.CLA, _this4.INS_SIGN_TRANSACTION, SIGN_TRANSACTION_SECTION_PREAMBLE, 0x01, preamble_);
      } else {
        yield _this4.transport.send(_this4.CLA, _this4.INS_SIGN_TRANSACTION, SIGN_TRANSACTION_SECTION_PREAMBLE, 0x00, preamble);
      }

      let remainingData = txn.slice(0); // copy
      let response;
      while (remainingData.length > 0) {
        const thisChunk = remainingData.slice(0, _this4.MAX_APDU_SIZE);
        remainingData = remainingData.slice(_this4.MAX_APDU_SIZE);
        response = yield _this4.transport.send(_this4.CLA, _this4.INS_SIGN_TRANSACTION, remainingData.length > 0 ? SIGN_TRANSACTION_SECTION_PAYLOAD_CHUNK : SIGN_TRANSACTION_SECTION_PAYLOAD_CHUNK_LAST, 0x00, thisChunk);
      }

      const responseHash = response.slice(0, 32);
      const expectedHash = Buffer.from((0, _createHash2.default)('sha256').update(txn).digest());
      if (!responseHash.equals(expectedHash)) {
        throw "Ledger reported a hash that does not match the expected transaction hash!";
      }

      return {
        hash: responseHash,
        signatures: yield _this4._collectSignaturesFromSuffixes(derivationPathSuffixes, _this4.INS_SIGN_TRANSACTION, SIGN_TRANSACTION_SECTION_SIGN_WITH_PATH, SIGN_TRANSACTION_SECTION_SIGN_WITH_PATH_LAST)
      };
    })();
  }

  /**
   * Get the version of the Avalanche app installed on the hardware device
   *
   * @return an object with a version
   * @example
   * console.log(await avalanche.getAppConfiguration());
   *
   * {
   *   "version": "1.0.3",
   *   "commit": "abcdcefg"
   *   "name": "Avalanche"
   * }
   */
  getAppConfiguration() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      const data = yield _this5.transport.send(_this5.CLA, _this5.INS_VERSION, 0x00, 0x00);

      const eatNBytes = function (input, n) {
        const out = input.slice(0, n);
        return [out, input.slice(n)];
      };

      const eatWhile = function (input, f) {
        for (var i = 0; i < input.length; i++) {
          if (!f(input[i])) {
            return [input.slice(0, i), input.slice(i)];
          }
        }
        return [input, ""];
      };

      const [versionData, rest1] = eatNBytes(data, 3);
      const [commitData, rest2] = eatWhile(rest1, function (c) {
        return c != 0;
      });
      const [nameData, rest3] = eatWhile(rest2.slice(1), function (c) {
        return c != 0;
      });
      if (rest3.toString("hex") != "009000") {
        _this5.logger("WARNING: Response data does not exactly match expected format for VERSION instruction");
      }

      return {
        version: "" + versionData[0] + "." + versionData[1] + "." + versionData[2],
        commit: commitData.toString("latin1"),
        name: nameData.toString("latin1")
      };
    })();
  }

  /**
   * Get the wallet identifier for the Ledger wallet
   *
   * @return a byte string
   * @example
   * console.log((await avalanche.getWalletId()).toString("hex"));
   *
   * 79c46bc3
   */
  getWalletId() {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      const result = yield _this6.transport.send(_this6.CLA, _this6.INS_GET_WALLET_ID, 0x00, 0x00);
      return result.slice(0, -2);
    })();
  }

  _collectSignaturesFromSuffixes(suffixes, ins, p1NotDone, p1Done) {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      let resultMap = new Map();
      for (let ix = 0; ix < suffixes.length; ix++) {
        const suffix = suffixes[ix];
        _this7.logger("Signing with " + suffix.toString(true));
        const message = _this7.encodeBip32Path(suffix);
        const isLastMessage = ix >= suffixes.length - 1;
        const signatureData = yield _this7.transport.send(_this7.CLA, ins, isLastMessage ? p1Done : p1NotDone, 0x00, message);
        resultMap.set(suffix.toString(true), signatureData.slice(0, -2));
      };
      return resultMap;
    })();
  }

  uInt8Buffer(uint8) {
    let buff = Buffer.alloc(1);
    buff.writeUInt8(uint8);
    return buff;
  }

  uInt32BEBuffer(uint32) {
    let buff = Buffer.alloc(4);
    buff.writeUInt32BE(uint32);
    return buff;
  }

  encodeBip32Path(path) {
    const pathArr = path.toPathArray();
    return Buffer.concat([this.uInt8Buffer(pathArr.length)].concat(pathArr.map(this.uInt32BEBuffer)));
  }
}
exports.default = Avalanche;
//# sourceMappingURL=Avalanche.js.map