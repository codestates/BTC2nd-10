{"version":3,"sources":["../src/Avalanche.js"],"names":["Avalanche","constructor","transport","scrambleKey","logger","console","error","CLA","MAX_APDU_SIZE","MAX_HRP_LENGTH","INS_VERSION","INS_GET_WALLET_ID","INS_PROMPT_PUBLIC_KEY","INS_PROMPT_EXT_PUBLIC_KEY","INS_SIGN_HASH","INS_SIGN_TRANSACTION","decorateAppAPIMethods","getWalletAddress","derivation_path","hrp","length","cla","ins","p1","p2","data","Buffer","concat","from","encodeBip32Path","BIPPath","fromString","response","send","slice","getWalletExtendedPublicKey","publicKeyLength","chainCodeOffset","chainCodeLength","public_key","chain_code","signHash","derivationPathPrefix","derivationPathSuffixes","hash","firstMessage","uInt8Buffer","responseHash","equals","_collectSignaturesFromSuffixes","signTransaction","txn","changePath","SIGN_TRANSACTION_SECTION_PREAMBLE","SIGN_TRANSACTION_SECTION_PAYLOAD_CHUNK","SIGN_TRANSACTION_SECTION_PAYLOAD_CHUNK_LAST","SIGN_TRANSACTION_SECTION_SIGN_WITH_PATH","SIGN_TRANSACTION_SECTION_SIGN_WITH_PATH_LAST","preamble","preamble_","remainingData","thisChunk","expectedHash","update","digest","signatures","getAppConfiguration","eatNBytes","input","n","out","eatWhile","f","i","versionData","rest1","commitData","rest2","c","nameData","rest3","toString","version","commit","name","getWalletId","result","suffixes","p1NotDone","p1Done","resultMap","Map","ix","suffix","message","isLastMessage","signatureData","set","uint8","buff","alloc","writeUInt8","uInt32BEBuffer","uint32","writeUInt32BE","path","pathArr","toPathArray","map"],"mappings":"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","file":"Avalanche.js","sourcesContent":["//@flow\n\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport BIPPath from \"bip32-path\";\nimport createHash from 'create-hash';\n\n/**\n * Avalanche API\n *\n * @example\n * import Avalanche from \"@obsidiansystems/hw-app-avalanche\";\n * const avalanche = new Avalanche(transport);\n */\nexport default class Avalanche {\n  transport: Transport<*>;\n  logger: (msg: string) => undefined;\n\n  CLA = 0x80;\n  MAX_APDU_SIZE = 230;\n  MAX_HRP_LENGTH = 24;\n\n  INS_VERSION = 0x00;\n  INS_GET_WALLET_ID = 0x01;\n  INS_PROMPT_PUBLIC_KEY = 0x02;\n  INS_PROMPT_EXT_PUBLIC_KEY = 0x03;\n  INS_SIGN_HASH = 0x04;\n  INS_SIGN_TRANSACTION = 0x05;\n\n  constructor(\n    transport: Transport<*>,\n    scrambleKey: string = \"Avalanche\",\n    logger: (msg: string) => undefined = console.error,\n  ) {\n    this.transport = transport;\n    this.logger = logger;\n    if (scrambleKey) {\n      transport.decorateAppAPIMethods(\n        this,\n        [\n          \"getAppConfiguration\",\n          \"getWalletAddress\",\n          \"getWalletExtendedPublicKey\",\n          \"getWalletId\",\n          \"signHash\",\n          \"signTransaction\",\n        ],\n        scrambleKey\n      );\n    }\n  }\n\n  /**\n   * get Avalanche address for a given BIP-32 path.\n   *\n   * @param derivation_path a path in BIP 32 format\n   * @return a buffer with a public key, and TODO: should be address, not public key\n   * @example\n   * await avalanche.getWalletPublicKey(\"44'/9000'/0'/0/0\");\n   */\n  async getWalletAddress(derivation_path: string, hrp = \"\"): Promise<Buffer> {\n    if (hrp.length > this.MAX_HRP_LENGTH) {\n      throw \"Maximum Bech32 'human readable part' length exceeded\";\n    }\n\n    const cla = this.CLA;\n    const ins = this.INS_PROMPT_PUBLIC_KEY;\n    const p1 = hrp.length;\n    const p2 = 0x00;\n    const data = Buffer.concat([\n      Buffer.from(hrp, \"latin1\"),\n      this.encodeBip32Path(BIPPath.fromString(derivation_path)),\n    ]);\n\n    const response = await this.transport.send(cla, ins, p1, p2, data);\n    return response.slice(0, -2);\n  }\n\n  /**\n   * get extended public key for a given BIP-32 path.\n   *\n   * @param derivation_path a path in BIP-32 format\n   * @return an object with a buffer for the public key data and a buffer for the chain code\n   * @example\n   * await avalanche.getWalletExtendedPublicKey(\"44'/9000'/0'/0/0\");\n   */\n  async getWalletExtendedPublicKey(derivation_path: string): Promise<{\n    public_key: Buffer,\n    chain_code: Buffer,\n  }> {\n    const cla = this.CLA;\n    const ins = this.INS_PROMPT_EXT_PUBLIC_KEY;\n    const p1 = 0x00;\n    const p2 = 0x00;\n    const data: Buffer = this.encodeBip32Path(BIPPath.fromString(derivation_path));\n\n    const response = await this.transport.send(cla, ins, p1, p2, data);\n    const publicKeyLength = response[0];\n    const chainCodeOffset = 2+publicKeyLength;\n    const chainCodeLength = response[1 + publicKeyLength];\n    return {\n      public_key: response.slice(1, 1 + publicKeyLength),\n      chain_code: response.slice(chainCodeOffset, chainCodeOffset + chainCodeLength),\n    };\n  }\n\n  /**\n   * Sign a hash with a given set of BIP-32 paths.\n   *\n   * @param derivationPathPrefix a BIP-32 path that will act as the prefix to all other signing paths.\n   * @param derivationPathSuffixes an array of BIP-32 path suffixes that will be\n   *                               appended to the prefix to form the final path for signing.\n   * @param hash 32-byte buffer containing the hash to sign\n   * @return a map of path suffixes (as strings) to signature buffers\n   * @example\n   * const signatures = await avalanche.signHash(\n   *   BIPPath.fromString(\"44'/9000'/0'\"),\n   *   [BIPPath.fromString(\"0/0\")],\n   *   Buffer.from(\"0000000000000000000000000000000000000000000000000000000000000000\", \"hex\"));\n   */\n  async signHash(\n    derivationPathPrefix: BIPPath,\n    derivationPathSuffixes: Array<BIPPath>,\n    hash: Buffer,\n  ): Promise<Map<string, Buffer>> {\n    if (hash.length != 32) {\n      throw \"Hash buffer must be 32 bytes\";\n    }\n\n    const firstMessage: Buffer = Buffer.concat([\n      this.uInt8Buffer(derivationPathSuffixes.length),\n      hash,\n      this.encodeBip32Path(derivationPathPrefix)\n    ]);\n    const responseHash = await this.transport.send(this.CLA, this.INS_SIGN_HASH, 0x00, 0x00, firstMessage);\n    if (!responseHash.slice(0, 32).equals(hash)) {\n      throw \"Ledger reported a hash that does not match the input hash!\";\n    }\n\n    return this._collectSignaturesFromSuffixes(derivationPathSuffixes, this.INS_SIGN_HASH, 0x01, 0x81);\n  }\n\n  /**\n   * Sign a transaction with a given set of BIP-32 paths.\n   *\n   * @param derivationPathPrefix a BIP-32 path that will act as the prefix to all other signing paths.\n   * @param derivationPathSuffixes an array of BIP-32 path suffixes that will be\n   *                               appended to the prefix to form the final path for signing.\n   * @param txn binary of the transaction\n   * @return an object with a hash of the transaction and a map of path suffixes (as strings) to signature buffers\n   * @example\n   * const signatures = await avalanche.signTransaction(\n   *   BIPPath.fromString(\"44'/9000'/0'\"),\n   *   [BIPPath.fromString(\"0/0\")],\n   *   Buffer.from(\"...\", \"hex\"),\n   *   BIPPath.fromString(\"44'/9000'/0'/0'/0'\"));\n   * );\n   */\n  async signTransaction(\n    derivationPathPrefix: BIPPath,\n    derivationPathSuffixes: Array<BIPPath>,\n    txn: Buffer,\n    changePath: ?BIPPath\n  ): Promise<{hash: Buffer, signatures: Map<string, Buffer>}> {\n\n    const SIGN_TRANSACTION_SECTION_PREAMBLE            = 0x00;\n    const SIGN_TRANSACTION_SECTION_PAYLOAD_CHUNK       = 0x01;\n    const SIGN_TRANSACTION_SECTION_PAYLOAD_CHUNK_LAST  = 0x81;\n    const SIGN_TRANSACTION_SECTION_SIGN_WITH_PATH      = 0x02;\n    const SIGN_TRANSACTION_SECTION_SIGN_WITH_PATH_LAST = 0x82;\n\n    const preamble = Buffer.concat([\n      this.uInt8Buffer(derivationPathSuffixes.length),\n      this.encodeBip32Path(derivationPathPrefix)\n    ]);\n    if (changePath != null) {\n      const preamble_ = Buffer.concat([\n        preamble,\n        this.encodeBip32Path(changePath)\n      ]);\n      await this.transport.send(this.CLA, this.INS_SIGN_TRANSACTION, SIGN_TRANSACTION_SECTION_PREAMBLE, 0x01, preamble_);\n    } else {\n      await this.transport.send(this.CLA, this.INS_SIGN_TRANSACTION, SIGN_TRANSACTION_SECTION_PREAMBLE, 0x00, preamble);\n    }\n\n    let remainingData = txn.slice(0); // copy\n    let response;\n    while (remainingData.length > 0) {\n      const thisChunk = remainingData.slice(0, this.MAX_APDU_SIZE);\n      remainingData = remainingData.slice(this.MAX_APDU_SIZE);\n      response = await this.transport.send(\n        this.CLA,\n        this.INS_SIGN_TRANSACTION,\n        remainingData.length > 0\n          ? SIGN_TRANSACTION_SECTION_PAYLOAD_CHUNK\n          : SIGN_TRANSACTION_SECTION_PAYLOAD_CHUNK_LAST,\n        0x00,\n        thisChunk,\n      );\n    }\n\n    const responseHash = response.slice(0, 32);\n    const expectedHash = Buffer.from(createHash('sha256').update(txn).digest());\n    if (!responseHash.equals(expectedHash)) {\n      throw \"Ledger reported a hash that does not match the expected transaction hash!\";\n    }\n\n    return {\n      hash: responseHash,\n      signatures: await this._collectSignaturesFromSuffixes(\n        derivationPathSuffixes,\n        this.INS_SIGN_TRANSACTION,\n        SIGN_TRANSACTION_SECTION_SIGN_WITH_PATH,\n        SIGN_TRANSACTION_SECTION_SIGN_WITH_PATH_LAST,\n      )\n    };\n  }\n\n  /**\n   * Get the version of the Avalanche app installed on the hardware device\n   *\n   * @return an object with a version\n   * @example\n   * console.log(await avalanche.getAppConfiguration());\n   *\n   * {\n   *   \"version\": \"1.0.3\",\n   *   \"commit\": \"abcdcefg\"\n   *   \"name\": \"Avalanche\"\n   * }\n   */\n  async getAppConfiguration(): Promise<{\n    version: string,\n    commit: string,\n    name: string,\n  }> {\n    const data: Buffer = await this.transport.send(this.CLA, this.INS_VERSION, 0x00, 0x00);\n\n    const eatNBytes = function(input, n) {\n      const out = input.slice(0, n);\n      return [out, input.slice(n)];\n    };\n\n    const eatWhile = function(input, f) {\n      for (var i = 0; i < input.length; i++) {\n        if (!f(input[i])) {\n          return [input.slice(0, i), input.slice(i)];\n        }\n      }\n      return [input, \"\"];\n    };\n\n    const [versionData, rest1] = eatNBytes(data, 3);\n    const [commitData, rest2] = eatWhile(rest1, c => c != 0);\n    const [nameData, rest3] = eatWhile(rest2.slice(1), c => c != 0);\n    if (rest3.toString(\"hex\") != \"009000\") {\n      this.logger(\"WARNING: Response data does not exactly match expected format for VERSION instruction\");\n    }\n\n    return {\n      version: \"\" + versionData[0] + \".\" + versionData[1] + \".\" + versionData[2],\n      commit: commitData.toString(\"latin1\"),\n      name: nameData.toString(\"latin1\")\n    };\n  }\n\n  /**\n   * Get the wallet identifier for the Ledger wallet\n   *\n   * @return a byte string\n   * @example\n   * console.log((await avalanche.getWalletId()).toString(\"hex\"));\n   *\n   * 79c46bc3\n   */\n  async getWalletId(): Promise<Buffer> {\n    const result = await this.transport.send(this.CLA, this.INS_GET_WALLET_ID, 0x00, 0x00);\n    return result.slice(0, -2);\n  }\n\n  async _collectSignaturesFromSuffixes(suffixes: Array<BIPPath>, ins: int, p1NotDone: int, p1Done: int) {\n    let resultMap: Map<string, Buffer> = new Map();\n    for (let ix = 0; ix < suffixes.length; ix++) {\n      const suffix = suffixes[ix];\n      this.logger(\"Signing with \" + suffix.toString(true));\n      const message: Buffer = this.encodeBip32Path(suffix);\n      const isLastMessage: Boolean = ix >= suffixes.length - 1;\n      const signatureData = await this.transport.send(this.CLA, ins, isLastMessage ? p1Done : p1NotDone, 0x00, message);\n      resultMap.set(suffix.toString(true), signatureData.slice(0, -2));\n    };\n    return resultMap;\n  }\n\n  uInt8Buffer(uint8: int): Buffer {\n    let buff = Buffer.alloc(1);\n    buff.writeUInt8(uint8);\n    return buff;\n  }\n\n  uInt32BEBuffer(uint32: int): Buffer {\n    let buff = Buffer.alloc(4);\n    buff.writeUInt32BE(uint32);\n    return buff;\n  }\n\n  encodeBip32Path(path: BIPPath): Buffer {\n    const pathArr = path.toPathArray();\n    return Buffer.concat([this.uInt8Buffer(pathArr.length)].concat(pathArr.map(this.uInt32BEBuffer)));\n  }\n}\n"]}